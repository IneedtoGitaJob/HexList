#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node{
int data;

struct Node* next0;
struct Node* next1;
struct Node* next2;
struct Node* next3;
struct Node* next4;
struct Node* next5;
struct Node* next6;
struct Node* next7;
struct Node* next8;
struct Node* next9;
struct Node* nextA;
struct Node* nextB;
struct Node* nextC;
struct Node* nextD;
struct Node* nextE;
struct Node* nextF;
}Node;

void Insert(struct Node* Head, int val);
void Point_To_NULL(struct Node* Head);
void Print_List(struct Node* HeadPoint);
//returns 1 if the value is in the list else returns 0
int Search(struct Node* HeadPoint, int val);
struct Node* Traverse(struct Node* current, char value);

int main (){

int New_val;
FILE* f = fopen("obagna.txt","r");
FILE* f2 = fopen("obagna.txt","r");
if(f == NULL){
    return 0;
}

struct Node* Head = (struct Node*)malloc(sizeof(Node));
Head->data = -1;
Point_To_NULL(Head);

while(fscanf(f,"%d",&New_val)!=EOF){
Insert(Head,New_val);
}

int ger = 0;
struct Node* HeadPoint = Head;
Print_List(HeadPoint);
/*
while(fscanf(f2,"%d",&New_val)!=EOF){

  ger = Search(Head,New_val);
   printf("%d\n", ger);
}
*/

return 1;
}

void Insert(struct Node* Head, int val)
{
//Inputs the hex value of a number into the array
char Hexed_val[9];
sprintf(Hexed_val, "%x", val);
printf("%s\n",Hexed_val);
struct Node* current = Head;
struct Node* prev = Head;


//Iterate until either an empty Node or the same value is found and create a new node when an empty node is found
for(int x = 0; x< strlen(Hexed_val);x++)
{
if(current != NULL)
{
            prev = current;
        if(current->data == val)
{
            printf("Duplicate value ignored");
        return;
}
    current = Traverse(current,Hexed_val[x]);
}
else
{
//creates new Node
struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
if(temp == NULL)
{
printf("Memory error");
return;
}
temp->data = val;
Point_To_NULL(temp);

switch(Hexed_val[x-1])
{
case '0':
prev->next0 = temp;
break;
case '1':
prev->next1 = temp;
break;
case '2':
prev->next2 = temp;
break;
case '3':
prev->next3 = temp;
break;
case '4':
prev->next4 = temp;
break;
case '5':
prev->next5 = temp;
break;
case '6':
prev->next6 = temp;
break;
case '7':
prev->next7 = temp;
break;
case '8':
prev->next8 = temp;
break;
case '9':
prev->next9 = temp;
break;
case 'a':
prev->nextA = temp;
break;
case 'b':
prev->nextB = temp;
break;
case 'c':
prev->nextC = temp;
break;
case 'd':
prev->nextD = temp;
break;
case 'e':
prev->nextE = temp;
break;
case 'f':
prev->nextF = temp;
break;
}
}
}
}

void Point_To_NULL(struct Node* Head){
Head->next0=NULL;
Head->next1=NULL;
Head->next2=NULL;
Head->next3=NULL;
Head->next4=NULL;
Head->next5=NULL;
Head->next6=NULL;
Head->next7=NULL;
Head->next8=NULL;
Head->next9=NULL;
Head->nextA=NULL;
Head->nextB=NULL;
Head->nextC=NULL;
Head->nextD=NULL;
Head->nextE=NULL;
Head->nextF=NULL;
}
//Prints the entire list
void Print_List(struct Node* current){
//If empty return
if(current !=NULL)
{
printf("%d ",current->data);
Print_List(current->next0);
Print_List(current->next1);
Print_List(current->next2);
Print_List(current->next3);
Print_List(current->next4);
Print_List(current->next5);
Print_List(current->next6);
Print_List(current->next7);
Print_List(current->next8);
Print_List(current->next9);
Print_List(current->nextA);
Print_List(current->nextB);
Print_List(current->nextC);
Print_List(current->nextD);
Print_List(current->nextE);
Print_List(current->nextF);
}
}

int Search(struct Node* HeadPoint, int val){
char Hexed_val[9];
sprintf(Hexed_val, "%x", val);
struct Node* current = HeadPoint;
int x = 0;

while(current != NULL)
{
if(current->data == val){return 1;}
else{current = Traverse(current, Hexed_val[x]);}
x++;
}

return 0;

}




struct Node* Traverse(struct Node* current, char value){
switch(value){
case '0':
    return current->next0;
break;
case '1':
    return current->next1;
break;
case '2':
    return current->next2;
break;
case '3':
    return current->next3;
break;
case '4':
    return current->next4;
break;
case '5':
    return current->next5;
break;
case '6':
    return current->next6;
break;
case '7':
    return current->next7;
break;
case '8':
    return current->next8;
break;
case '9':
    return current->next9;
break;
case 'a':
    return current->nextA;
break;
case 'b':
    return current->nextB;
break;
case 'c':
    return current->nextC;
break;
case 'd':
    return current->nextD;
break;
case 'e':
    return current->nextE;
break;
case 'f':
    return current->nextF;
break;
}
}


